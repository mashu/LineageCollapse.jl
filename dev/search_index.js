var documenterSearchIndex = {"docs":
[{"location":"#LineageCollapse","page":"Home","title":"LineageCollapse","text":"Documentation for LineageCollapse, a Julia package for collapsing lineages in AIRR data.","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"LineageCollapse provides tools for processing and analyzing adaptive immune receptor repertoire (AIRR) data. It offers functions for data loading, preprocessing, lineage collapsing.","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"You can install LineageCollapse using Julia's package manager:\n\nusing Pkg\nPkg.add(\"LineageCollapse\")","category":"section"},{"location":"#Basic-Usage","page":"Home","title":"Basic Usage","text":"Here's a quick example of how to use LineageCollapse:\n\nusing LineageCollapse\n\n# Load data\ndf = load_data(\"path/to/your/airr_data.tsv.gz\")\n\n# Preprocess data\npreprocessed_df = preprocess_data(df, min_d_region_length=3)\n\n# Assign lineages using default absolute mismatch distance 1\nresult1 = process_lineages(preprocessed_df)\n\n# Assign lineages using a CDR3 mismatch fraction (0.1 = 10%)\nresult2 = process_lineages(preprocessed_df, 0.1)\n\n# Assign lineages using an absolute mismatch threshold (<= 1 mismatch)\nresult3 = process_lineages(preprocessed_df, 1)\n# Collapse\ncollapsed_df = collapse_lineages(lineages, Soft(0.2))\n\n# Generate diagnostic plots (requires CairoMakie)\n# using CairoMakie\n# plot_diagnostics(collapsed_df)\n\nFor more detailed information on each function and its options, please refer to the API documentation below.\n\n","category":"section"},{"location":"#LineageCollapse.HierarchicalClustering","page":"Home","title":"LineageCollapse.HierarchicalClustering","text":"HierarchicalClustering(cutoff::Float32)\n\nA type representing hierarchical clustering with a cutoff.\n\nArguments\n\ncutoff::Float32: The cutoff value for the clustering, below which clusters are merged. Higher values result in fewer clusters.\n\n\n\n\n\n","category":"type"},{"location":"#LineageCollapse.collapse_lineages","page":"Home","title":"LineageCollapse.collapse_lineages","text":"collapse_lineages(df::DataFrame, strategy::CollapseStrategy=Hardest())\n\nCollapse lineages in a DataFrame based on clone frequency and a specified collapse strategy.\n\nArguments\n\ndf::DataFrame: Input DataFrame containing lineage data. Must have columns [:dregion, :lineageid, :jcallfirst, :vcallfirst, :cdr3].\nstrategy::CollapseStrategy=Hardest(): Strategy for collapsing lineages.\nHardest() selects only the most frequent clone per lineage.\nSoft(cutoff) keeps clones whose frequency within a lineage is at or above cutoff.\n\nReturns\n\nDataFrame: Collapsed lineage data containing a new column:\nclone_frequency: Represents the relative frequency of each clone within its lineage, calculated as (count of specific clone) / (total sequences in lineage). A clone is defined by unique combination of D region, J call, V call, and CDR3 sequence. Values range from 0.0 to 1.0, with higher values indicating more abundant clones in the lineage.\n\nExample\n\nlineages = DataFrame(...)  # Your input data\ncollapsed = collapse_lineages(lineages, Soft(0.1))\n\n\n\n\n\n","category":"function"},{"location":"#LineageCollapse.compute_distance-Tuple{HammingDistance, BioSequences.LongSequence{BioSequences.DNAAlphabet{4}}, BioSequences.LongSequence{BioSequences.DNAAlphabet{4}}}","page":"Home","title":"LineageCollapse.compute_distance","text":"compute_distance(metric::DistanceMetric, x::LongDNA{4}, y::LongDNA{4})::Float32\n\nCompute the distance between two LongDNA{4} sequences using the specified distance metric.\n\n\n\n\n\n","category":"method"},{"location":"#LineageCollapse.compute_distance-Tuple{LevenshteinDistance, BioSequences.LongSequence{BioSequences.DNAAlphabet{4}}, BioSequences.LongSequence{BioSequences.DNAAlphabet{4}}}","page":"Home","title":"LineageCollapse.compute_distance","text":"compute_distance(metric::DistanceMetric, x::LongDNA{4}, y::LongDNA{4})::Float32\n\nCompute the distance between two LongDNA{4} sequences using the specified distance metric.\n\n\n\n\n\n","category":"method"},{"location":"#LineageCollapse.compute_distance-Tuple{NormalizedHammingDistance, BioSequences.LongSequence{BioSequences.DNAAlphabet{4}}, BioSequences.LongSequence{BioSequences.DNAAlphabet{4}}}","page":"Home","title":"LineageCollapse.compute_distance","text":"compute_distance(metric::DistanceMetric, x::LongDNA{4}, y::LongDNA{4})::Float32\n\nCompute the distance between two LongDNA{4} sequences using the specified distance metric.\n\n\n\n\n\n","category":"method"},{"location":"#LineageCollapse.compute_pairwise_distance-Union{Tuple{S}, Tuple{M}, Tuple{M, AbstractVector{S}}} where {M<:Union{DistanceMetric, LineageCollapse.NormalizedDistanceMetric}, S<:BioSequences.LongSequence{BioSequences.DNAAlphabet{4}}}","page":"Home","title":"LineageCollapse.compute_pairwise_distance","text":"compute_pairwise_distance(metric::Union{DistanceMetric, NormalizedDistanceMetric}, sequences::Vector{LongDNA{4}})::Matrix{Float32}\n\nCompute pairwise distances between sequences using the specified distance metric.\n\n\n\n\n\n","category":"method"},{"location":"#LineageCollapse.deduplicate_data","page":"Home","title":"LineageCollapse.deduplicate_data","text":"deduplicate_data(df::DataFrame, use_barcode::Bool=false)::DataFrame\n\nDeduplicate the input DataFrame based on sequence or sequence+barcode.\n\nArguments\n\ndf::DataFrame: Input DataFrame.\nuse_barcode::Bool=false: Whether to use barcode for deduplication.\n\nReturns\n\nDataFrame: Deduplicated DataFrame.\n\n\n\n\n\n","category":"function"},{"location":"#LineageCollapse.load_data-Tuple{String}","page":"Home","title":"LineageCollapse.load_data","text":"load_data(filepath::String; \n          delimiter::Char='\t', \n          required_columns=[:sequence_id, :sequence, :v_sequence_end, :j_sequence_start, :cdr3, :v_call, :j_call, :stop_codon])::DataFrame\n\nLoad data from a file (compressed or uncompressed) and return a DataFrame.\n\nArguments\n\nfilepath::String: Path to the data file.\ndelimiter::Char='\t': Delimiter used in the data file (default: tab).\nrequired_columns::Vector{Symbol}: Required columns to select from the data file.\n\nReturns\n\nDataFrame: DataFrame containing the loaded data.\n\nThrows\n\nArgumentError: If any of the required columns are missing in the data file.\n\n\n\n\n\n","category":"method"},{"location":"#LineageCollapse.perform_clustering-Union{Tuple{T}, Tuple{HierarchicalClustering, Symbol, T}} where T<:(AbstractMatrix)","page":"Home","title":"LineageCollapse.perform_clustering","text":"perform_clustering(method::HierarchicalClustering, linkage::Symbol, dist_matrix::T)::Vector{Int} where T <: AbstractMatrix\n\nPerform hierarchical clustering on the distance matrix using the specified method and linkage.\n\n\n\n\n\n","category":"method"},{"location":"#LineageCollapse.preprocess_data-Tuple{DataFrames.DataFrame}","page":"Home","title":"LineageCollapse.preprocess_data","text":"preprocess_data(df::DataFrame; min_d_region_length::Union{Int,Nothing}=nothing, deduplicate::Bool=false, use_barcode::Bool=false)::DataFrame\n\nPreprocess the input DataFrame by performing data cleaning and transformation.\n\nArguments\n\ndf::DataFrame: Input DataFrame.\nmin_d_region_length::Union{Int,Nothing}=nothing: Minimum length of the D region to keep. If nothing, no filtering is applied.\ndeduplicate::Bool=false: Whether to deduplicate the DataFrame.\nuse_barcode::Bool=false: Whether to use barcode for deduplication (only applicable if deduplicate is true).\n\nReturns\n\nDataFrame: Preprocessed DataFrame.\n\n\n\n\n\n","category":"method"},{"location":"#LineageCollapse.process_lineages-Tuple{DataFrames.DataFrame, Union{AbstractFloat, Integer}}","page":"Home","title":"LineageCollapse.process_lineages","text":"process_lineages(df::DataFrame, cdr3_mismatch_threshold::Union{Integer,AbstractFloat};\n                 linkage::Symbol = :single)::DataFrame\n\nProcess lineages from a DataFrame of CDR3 sequences using a mismatch threshold.\n\nIf cdr3_mismatch_threshold is an Integer, it is interpreted as an absolute number of allowed mismatches. If it is a floating-point value, it is interpreted as a fraction of the CDR3 length (0.0 to 1.0). Use an integer literal (e.g. 1) to request absolute mismatches when 1.0 would be ambiguous.\n\n\n\n\n\n","category":"method"},{"location":"#LineageCollapse.process_lineages-Tuple{DataFrames.DataFrame}","page":"Home","title":"LineageCollapse.process_lineages","text":"process_lineages(df::DataFrame;\n                distance_metric::Union{DistanceMetric, NormalizedDistanceMetric} = HammingDistance(),\n                clustering_method::ClusteringMethod = HierarchicalClustering(1.0),\n                linkage::Symbol = :single)::DataFrame\n\nProcess lineages from a DataFrame of CDR3 sequences.\n\n\n\n\n\n","category":"method"}]
}
