var documenterSearchIndex = {"docs":
[{"location":"#LineageCollapse","page":"Home","title":"LineageCollapse","text":"Documentation for LineageCollapse, a Julia package for collapsing lineages in AIRR data.","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"LineageCollapse provides tools for processing and analyzing adaptive immune receptor repertoire (AIRR) data. It offers functions for data loading, preprocessing, lineage collapsing.","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"You can install LineageCollapse using Julia's package manager:\n\nusing Pkg\nPkg.add(\"LineageCollapse\")","category":"section"},{"location":"#Basic-Usage","page":"Home","title":"Basic Usage","text":"Here's a quick example of how to use LineageCollapse:\n\nusing LineageCollapse\n\n# Load data\ndf = load_data(\"path/to/your/airr_data.tsv.gz\")\n\n# Preprocess data\npreprocessed_df = preprocess_data(df, min_d_region_length=3)\n\n# Assign lineages using default absolute mismatch distance 1\nresult1 = process_lineages(preprocessed_df)\n\n# Assign lineages using a CDR3 mismatch fraction (0.1 = 10%)\nresult2 = process_lineages(preprocessed_df, 0.1)\n\n# Assign lineages using an absolute mismatch threshold (<= 1 mismatch)\nresult3 = process_lineages(preprocessed_df, 1)\n# Collapse\ncollapsed_df = collapse_lineages(lineages, Soft(0.2))\n\n# Generate diagnostic plots (requires CairoMakie)\n# using CairoMakie\n# plot_diagnostics(collapsed_df)\n\nFor more detailed information on each function and its options, please refer to the API documentation below.\n\n","category":"section"},{"location":"#LineageCollapse.HierarchicalClustering","page":"Home","title":"LineageCollapse.HierarchicalClustering","text":"HierarchicalClustering(cutoff::Float32)\n\nA type representing hierarchical clustering with a cutoff.\n\nArguments\n\ncutoff::Float32: The cutoff value for the clustering, below which clusters are merged. Higher values result in fewer clusters.\n\n\n\n\n\n","category":"type"},{"location":"#LineageCollapse.MostCommonVdjNtTieBreaker","page":"Home","title":"LineageCollapse.MostCommonVdjNtTieBreaker","text":"MostCommonVdjNtTieBreaker\n\nA tie-breaker that selects the representative based on the most common VDJ_nt sequence weighted by count, matching igdiscover's clonotypes behavior.\n\nFor each lineage, it:\n\nSums the count for each unique vdj_nt sequence\nSelects the vdj_nt with the highest total count\nReturns the first row with that vdj_nt\n\n\n\n\n\n","category":"type"},{"location":"#LineageCollapse.ByMostCommonVdjNt-Tuple{}","page":"Home","title":"LineageCollapse.ByMostCommonVdjNt","text":"ByMostCommonVdjNt()\n\nCreate a tie-breaker that matches igdiscover's clonotypes representative selection.\n\nSelects the representative by finding the VDJnt sequence with the highest total count across all members of the lineage, then returns the first row with that VDJnt.\n\nRequires columns: vdj_nt, count\n\n\n\n\n\n","category":"method"},{"location":"#LineageCollapse.add_vdj_count-Tuple{DataFrames.DataFrame}","page":"Home","title":"LineageCollapse.add_vdj_count","text":"add_vdj_count(df::DataFrame) -> DataFrame\n\nAdd vdj_count column showing the count of each unique VDJ sequence within each clone.\n\n\n\n\n\n","category":"method"},{"location":"#LineageCollapse.apply_aggregates-Tuple{DataFrames.DataFrame, LineageCollapse.LineageAggregates}","page":"Home","title":"LineageCollapse.apply_aggregates","text":"apply_aggregates(collapsed::DataFrame, agg::LineageAggregates) -> DataFrame\n\nApply precomputed aggregates to the collapsed DataFrame.\n\n\n\n\n\n","category":"method"},{"location":"#LineageCollapse.apply_aggregates-Tuple{DataFrames.DataFrame, LineageCollapse.NoAggregates}","page":"Home","title":"LineageCollapse.apply_aggregates","text":"apply_aggregates(collapsed::DataFrame, ::NoAggregates) -> DataFrame\n\nNo-op when there are no aggregates to apply.\n\n\n\n\n\n","category":"method"},{"location":"#LineageCollapse.clone_frequency_table-Tuple{DataFrames.DataFrame}","page":"Home","title":"LineageCollapse.clone_frequency_table","text":"clone_frequency_table(df::DataFrame) -> DataFrame\n\nCompute clone frequency for each unique clone within each lineage.\n\n\n\n\n\n","category":"method"},{"location":"#LineageCollapse.collapse_group-Tuple{Hardest, DataFrames.AbstractDataFrame, AbstractTieBreaker, Real}","page":"Home","title":"LineageCollapse.collapse_group","text":"collapse_group(::Hardest, group::AbstractDataFrame, tie_breaker::AbstractTieBreaker, tie_atol::Real)\n\nCollapse a lineage group using Hardest strategy - select the most frequent clone.\n\n\n\n\n\n","category":"method"},{"location":"#LineageCollapse.collapse_group-Tuple{Soft, DataFrames.AbstractDataFrame, AbstractTieBreaker, Real}","page":"Home","title":"LineageCollapse.collapse_group","text":"collapse_group(strategy::Soft, group::AbstractDataFrame, ::AbstractTieBreaker, ::Real)\n\nCollapse a lineage group using Soft strategy - keep clones above frequency cutoff.\n\n\n\n\n\n","category":"method"},{"location":"#LineageCollapse.collapse_lineages","page":"Home","title":"LineageCollapse.collapse_lineages","text":"collapse_lineages(df::DataFrame, strategy::CollapseStrategy=Hardest();\n                  tie_breaker::AbstractTieBreaker=ByMostCommonVdjNt(),\n                  tie_atol::Real=0.0)\n\nCollapse lineages in a DataFrame based on clone frequency and a specified collapse strategy.\n\nWhen using Hardest() strategy (one representative per lineage), the function automatically:\n\nSums the count column across all members of each lineage\nAdds nVDJ_nt column with the number of unique VDJ_nt sequences per lineage\n\nThe default tie_breaker=ByMostCommonVdjNt() matches igdiscover's clonotypes behavior.\n\nArguments\n\ndf::DataFrame: Input DataFrame containing lineage data. Must have columns [:dregion, :lineageid, :jcallfirst, :vcallfirst, :cdr3].\nstrategy::CollapseStrategy=Hardest(): Strategy for collapsing lineages.\nHardest() selects only the most frequent clone per lineage.\nSoft(cutoff) keeps clones whose frequency within a lineage is at or above cutoff.\ntie_breaker::AbstractTieBreaker=ByMostCommonVdjNt(): Tie-breaking policy when multiple clones share the maximum clone_frequency under Hardest(). Default ByMostCommonVdjNt() matches igdiscover's behavior. Other options:\nByMostCommonVdjNt() (default): Matches igdiscover's clonotypes behavior - selects the row with the most common vdj_nt weighted by count. Requires vdj_nt column.\nByVdjCount(): Requires a vdj_nt column (derived in preprocess_data when v_sequence_start and j_sequence_end are available).\nByCdr3Count(), ByLexicographic(), BySequenceCount(), ByFirst(), ByMostNaive().\nCompose rules with + (e.g. ByVdjCount() + ByMostNaive()).\ntie_atol::Real=0.0: Absolute tolerance for considering clone frequencies equal when identifying ties.\n\nReturns\n\nDataFrame: Collapsed lineage data containing:\nclone_frequency: Relative frequency of each clone within its lineage (0.0 to 1.0).\nFor Hardest() strategy:\ncount: Sum of counts across all lineage members\nnVDJ_nt: Number of unique VDJ_nt sequences in the lineage\n\nExample\n\nlineages = DataFrame(...)  # Your input data\n\n# Default collapse (matches igdiscover's clonotypes output)\ncollapsed = collapse_lineages(lineages, Hardest())\n\n# Use alternative tie-breaker\ncollapsed = collapse_lineages(lineages, Hardest(); tie_breaker=ByVdjCount())\n\n# Soft collapse (keeps multiple clones per lineage)\ncollapsed = collapse_lineages(lineages, Soft(0.1))\n\n\n\n\n\n","category":"function"},{"location":"#LineageCollapse.compute_aggregates-Tuple{Hardest, DataFrames.AbstractDataFrame}","page":"Home","title":"LineageCollapse.compute_aggregates","text":"compute_aggregates(::Hardest, df::AbstractDataFrame) -> LineageAggregates\n\nCompute aggregated statistics for each lineage when using Hardest strategy.\n\n\n\n\n\n","category":"method"},{"location":"#LineageCollapse.compute_aggregates-Tuple{Soft, DataFrames.AbstractDataFrame}","page":"Home","title":"LineageCollapse.compute_aggregates","text":"compute_aggregates(::Soft, ::AbstractDataFrame) -> NoAggregates\n\nSoft strategy does not aggregate - returns sentinel type.\n\n\n\n\n\n","category":"method"},{"location":"#LineageCollapse.compute_distance-Tuple{HammingDistance, BioSequences.LongSequence{BioSequences.DNAAlphabet{4}}, BioSequences.LongSequence{BioSequences.DNAAlphabet{4}}}","page":"Home","title":"LineageCollapse.compute_distance","text":"compute_distance(metric::DistanceMetric, x::LongDNA{4}, y::LongDNA{4})::Float32\n\nCompute the distance between two LongDNA{4} sequences using the specified distance metric.\n\n\n\n\n\n","category":"method"},{"location":"#LineageCollapse.compute_distance-Tuple{LevenshteinDistance, BioSequences.LongSequence{BioSequences.DNAAlphabet{4}}, BioSequences.LongSequence{BioSequences.DNAAlphabet{4}}}","page":"Home","title":"LineageCollapse.compute_distance","text":"compute_distance(metric::DistanceMetric, x::LongDNA{4}, y::LongDNA{4})::Float32\n\nCompute the distance between two LongDNA{4} sequences using the specified distance metric.\n\n\n\n\n\n","category":"method"},{"location":"#LineageCollapse.compute_distance-Tuple{NormalizedHammingDistance, BioSequences.LongSequence{BioSequences.DNAAlphabet{4}}, BioSequences.LongSequence{BioSequences.DNAAlphabet{4}}}","page":"Home","title":"LineageCollapse.compute_distance","text":"compute_distance(metric::DistanceMetric, x::LongDNA{4}, y::LongDNA{4})::Float32\n\nCompute the distance between two LongDNA{4} sequences using the specified distance metric.\n\n\n\n\n\n","category":"method"},{"location":"#LineageCollapse.compute_pairwise_distance-Union{Tuple{S}, Tuple{M}, Tuple{M, AbstractVector{S}}} where {M<:Union{DistanceMetric, LineageCollapse.NormalizedDistanceMetric}, S<:BioSequences.LongSequence{BioSequences.DNAAlphabet{4}}}","page":"Home","title":"LineageCollapse.compute_pairwise_distance","text":"compute_pairwise_distance(metric::Union{DistanceMetric, NormalizedDistanceMetric}, sequences::Vector{LongDNA{4}})::Matrix{Float32}\n\nCompute pairwise distances between sequences using the specified distance metric.\n\n\n\n\n\n","category":"method"},{"location":"#LineageCollapse.deduplicate_data","page":"Home","title":"LineageCollapse.deduplicate_data","text":"deduplicate_data(df::DataFrame, use_barcode::Bool=false)::DataFrame\n\nDeduplicate the input DataFrame based on sequence or sequence+barcode.\n\nArguments\n\ndf::DataFrame: Input DataFrame.\nuse_barcode::Bool=false: Whether to use barcode for deduplication.\n\nReturns\n\nDataFrame: Deduplicated DataFrame.\n\n\n\n\n\n","category":"function"},{"location":"#LineageCollapse.hardest_tie_summary-Tuple{DataFrames.DataFrame}","page":"Home","title":"LineageCollapse.hardest_tie_summary","text":"hardest_tie_summary(df::DataFrame; atol::Real=0.0)::DataFrame\n\nSummarize lineages where multiple clones share the maximum clone frequency. Returns a DataFrame with one row per lineage, including the count of tied clones and the CDR3s involved in the tie. Set atol to a positive value to treat frequencies within that tolerance as equal.\n\n\n\n\n\n","category":"method"},{"location":"#LineageCollapse.load_data-Tuple{String}","page":"Home","title":"LineageCollapse.load_data","text":"load_data(filepath::String; \n          delimiter::Char='\t', \n          required_columns=[:sequence_id, :sequence, :v_sequence_end, :j_sequence_start, :cdr3, :v_call, :j_call, :stop_codon])::DataFrame\n\nLoad data from a file (compressed or uncompressed) and return a DataFrame.\n\nArguments\n\nfilepath::String: Path to the data file.\ndelimiter::Char='\t': Delimiter used in the data file (default: tab).\nrequired_columns::Vector{Symbol}: Required columns to select from the data file.\n\nReturns\n\nDataFrame: DataFrame containing the loaded data.\n\nThrows\n\nArgumentError: If any of the required columns are missing in the data file.\n\n\n\n\n\n","category":"method"},{"location":"#LineageCollapse.perform_clustering-Union{Tuple{T}, Tuple{HierarchicalClustering, Symbol, T}} where T<:(AbstractMatrix)","page":"Home","title":"LineageCollapse.perform_clustering","text":"perform_clustering(method::HierarchicalClustering, linkage::Symbol, dist_matrix::T)::Vector{Int} where T <: AbstractMatrix\n\nPerform hierarchical clustering on the distance matrix using the specified method and linkage.\n\n\n\n\n\n","category":"method"},{"location":"#LineageCollapse.preprocess_data-Tuple{DataFrames.DataFrame}","page":"Home","title":"LineageCollapse.preprocess_data","text":"preprocess_data(df::DataFrame; min_d_region_length::Union{Int,Nothing}=nothing, deduplicate::Bool=false, use_barcode::Bool=false)::DataFrame\n\nPreprocess the input DataFrame by performing data cleaning and transformation.\n\nArguments\n\ndf::DataFrame: Input DataFrame.\nmin_d_region_length::Union{Int,Nothing}=nothing: Minimum length of the D region to keep. If nothing, no filtering is applied.\ndeduplicate::Bool=false: Whether to deduplicate the DataFrame.\nuse_barcode::Bool=false: Whether to use barcode for deduplication (only applicable if deduplicate is true).\n\nReturns\n\nDataFrame: Preprocessed DataFrame.\n\n\n\n\n\n","category":"method"},{"location":"#LineageCollapse.process_lineages-Tuple{DataFrames.DataFrame, Union{AbstractFloat, Integer}}","page":"Home","title":"LineageCollapse.process_lineages","text":"process_lineages(df::DataFrame, cdr3_mismatch_threshold::Union{Integer,AbstractFloat};\n                 linkage::Symbol = :single)::DataFrame\n\nProcess lineages from a DataFrame of CDR3 sequences using a mismatch threshold.\n\nIf cdr3_mismatch_threshold is an Integer, it is interpreted as an absolute number of allowed mismatches. If it is a floating-point value, it is interpreted as a fraction of the CDR3 length (0.0 to 1.0). Use an integer literal (e.g. 1) to request absolute mismatches when 1.0 would be ambiguous.\n\n\n\n\n\n","category":"method"},{"location":"#LineageCollapse.process_lineages-Tuple{DataFrames.DataFrame}","page":"Home","title":"LineageCollapse.process_lineages","text":"process_lineages(df::DataFrame;\n                distance_metric::Union{DistanceMetric, NormalizedDistanceMetric} = HammingDistance(),\n                clustering_method::ClusteringMethod = HierarchicalClustering(1.0),\n                linkage::Symbol = :single)::DataFrame\n\nProcess lineages from a DataFrame of CDR3 sequences.\n\n\n\n\n\n","category":"method"},{"location":"#LineageCollapse.requires_vdj_count-Tuple{LineageCollapse.MostCommonVdjNtTieBreaker}","page":"Home","title":"LineageCollapse.requires_vdj_count","text":"requires_vdj_count(::MostCommonVdjNtTieBreaker) -> Bool\n\n\n\n\n\n","category":"method"},{"location":"#LineageCollapse.requires_vdj_count-Tuple{TieBreaker}","page":"Home","title":"LineageCollapse.requires_vdj_count","text":"requires_vdj_count(tie_breaker::TieBreaker) -> Bool\n\n\n\n\n\n","category":"method"},{"location":"#LineageCollapse.requires_vdj_nt-Tuple{LineageCollapse.MostCommonVdjNtTieBreaker}","page":"Home","title":"LineageCollapse.requires_vdj_nt","text":"requires_vdj_nt(::MostCommonVdjNtTieBreaker) -> Bool\n\n\n\n\n\n","category":"method"},{"location":"#LineageCollapse.requires_vdj_nt-Tuple{TieBreaker}","page":"Home","title":"LineageCollapse.requires_vdj_nt","text":"requires_vdj_nt(tie_breaker::TieBreaker) -> Bool\n\n\n\n\n\n","category":"method"},{"location":"#LineageCollapse.select_hardest_candidate-Tuple{DataFrames.AbstractDataFrame, TieBreaker}","page":"Home","title":"LineageCollapse.select_hardest_candidate","text":"select_hardest_candidate(candidates::AbstractDataFrame, tie_breaker::TieBreaker)\n\nSelect representative from candidates using TieBreaker sorting criteria. Returns the first row after sorting by the specified columns.\n\n\n\n\n\n","category":"method"},{"location":"#LineageCollapse.select_representative-Tuple{TieBreaker, DataFrames.AbstractDataFrame, DataFrames.AbstractDataFrame}","page":"Home","title":"LineageCollapse.select_representative","text":"select_representative(tie_breaker::TieBreaker, ::AbstractDataFrame, candidates::AbstractDataFrame)\n\nSelect representative from candidates using TieBreaker sorting criteria.\n\n\n\n\n\n","category":"method"}]
}
