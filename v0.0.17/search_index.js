var documenterSearchIndex = {"docs":
[{"location":"#LineageCollapse","page":"Home","title":"LineageCollapse","text":"Documentation for LineageCollapse, a Julia package for collapsing lineages in AIRR data.","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"LineageCollapse provides tools for processing and analyzing adaptive immune receptor repertoire (AIRR) data. It offers functions for data loading, preprocessing, lineage assignment, and lineage collapsing.","category":"section"},{"location":"#Architecture","page":"Home","title":"Architecture","text":"","category":"section"},{"location":"#Processing-Pipeline","page":"Home","title":"Processing Pipeline","text":"The library follows a linear pipeline where each stage transforms your data:\n\n┌─────────────────────────────────────────────────────────────────────────────┐\n│                          LineageCollapse Pipeline                           │\n└─────────────────────────────────────────────────────────────────────────────┘\n\n   AIRR TSV File\n        │\n        ▼\n┌───────────────┐\n│  load_data()  │  Load and validate AIRR-formatted data\n└───────┬───────┘\n        │ DataFrame\n        ▼\n┌──────────────────────┐\n│  preprocess_data()   │  Filter, derive D-region, normalize columns\n└──────────┬───────────┘\n           │ DataFrame + d_region, v_call_first, j_call_first\n           ▼\n┌────────────────────────────────────────────────────────────────────────────┐\n│  process_lineages(df, threshold)                                           │\n│  ┌──────────────────────────────────────────────────────────────────────┐  │\n│  │  For each (V-gene, J-gene, CDR3-length) group:                       │  │\n│  │    1. Compute pairwise CDR3 distances (AbstractDistanceMetric)       │  │\n│  │    2. Cluster sequences (ClusteringMethod)                           │  │\n│  │    3. Assign lineage_id to each cluster                              │  │\n│  └──────────────────────────────────────────────────────────────────────┘  │\n└──────────┬─────────────────────────────────────────────────────────────────┘\n           │ DataFrame + lineage_id, cluster, cluster_size, cdr3_frequency\n           ▼\n┌────────────────────────────────────────────────────────────────────────────┐\n│  collapse_lineages(df, strategy)                                           │\n│  ┌──────────────────────────────────────────────────────────────────────┐  │\n│  │  CollapseStrategy determines output:                                 │  │\n│  │    • Hardest() → one representative per lineage                      │  │\n│  │    • Soft(cutoff) → all clones above frequency threshold             │  │\n│  │                                                                      │  │\n│  │  AbstractTieBreaker resolves ties when selecting representatives     │  │\n│  └──────────────────────────────────────────────────────────────────────┘  │\n└──────────┬─────────────────────────────────────────────────────────────────┘\n           │\n           ▼\n   Collapsed DataFrame (representatives or filtered clones)","category":"section"},{"location":"#Type-Hierarchy","page":"Home","title":"Type Hierarchy","text":"The library uses Julia's multiple dispatch with abstract types for extensibility:\n\nAbstractDistanceMetric           ClusteringMethod              CollapseStrategy\n         │                              │                             │\n         ├── HammingDistance            └── HierarchicalClustering    ├── Hardest\n         ├── NormalizedHammingDistance          │                     └── Soft\n         └── LevenshteinDistance                └── cutoff::Float\n                                                                           │\n                                                                           │\nAbstractTieBreaker ◄───────────────────────────────────────────────────────┘\n         │                                                    (used by Hardest)\n         ├── TieBreaker\n         │       └── criteria::Vector{Pair{Symbol,Bool}}\n         │\n         └── MostCommonVdjNtTieBreaker","category":"section"},{"location":"#Extension-Points","page":"Home","title":"Extension Points","text":"You can extend the library by defining new types and methods:\n\nCustom Distance Metric:\n\nstruct MyDistance <: AbstractDistanceMetric end\n\n# Implement the required method\nLineageCollapse.compute_distance(::MyDistance, x::LongDNA{4}, y::LongDNA{4}) = ...\n\nCustom Tie-Breaker:\n\nstruct MyTieBreaker <: AbstractTieBreaker end\n\n# Or use the built-in TieBreaker with custom criteria\nmy_breaker = TieBreaker([:my_column => true, :cdr3 => false])","category":"section"},{"location":"#Key-Concepts","page":"Home","title":"Key Concepts","text":"Concept Description\nLineage Group of sequences sharing V-gene, J-gene, CDR3 length, and similar CDR3\nClone Unique combination of D-region + lineage + V + J + CDR3 within a lineage\nClone Frequency Proportion of sequences in a lineage belonging to a clone\nRepresentative Selected sequence to represent an entire lineage","category":"section"},{"location":"#Built-in-Tie-Breakers","page":"Home","title":"Built-in Tie-Breakers","text":"Function Strategy\nByMostCommonVdjNt() Most common VDJ nucleotide sequence (igdiscover-compatible)\nByVdjCount() Highest VDJ count, then lexicographic CDR3\nByCdr3Count() Highest CDR3 count, then lexicographic CDR3\nBySequenceCount() Highest sequence count, then lexicographic CDR3\nByMostNaive() Highest V/J identity (closest to germline)\nByLexicographic() Lexicographically smallest CDR3\nByFirst() First candidate (no sorting)\n\nTie-breakers can be combined: ByVdjCount() + ByLexicographic()","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"using Pkg\nPkg.add(\"LineageCollapse\")","category":"section"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"using LineageCollapse\n\n# Load and preprocess\ndf = load_data(\"airr_data.tsv.gz\")\ndf = preprocess_data(df; min_d_region_length=3)\n\n# Assign lineages (threshold: 1 mismatch or 0.1 = 10% of CDR3 length)\nlineages = process_lineages(df, 1)\n\n# Collapse options:\n# Option A: One representative per lineage\nresult = collapse_lineages(lineages, Hardest())\n\n# Option B: Keep clones with frequency ≥ 20%\nresult = collapse_lineages(lineages, Soft(0.2))\n\n# Option C: Custom tie-breaking\nresult = collapse_lineages(lineages, Hardest(); \n                           tie_breaker=ByMostNaive(),\n                           tie_atol=0.01)  # 1% tolerance","category":"section"},{"location":"#Detailed-Examples","page":"Home","title":"Detailed Examples","text":"","category":"section"},{"location":"#Using-Different-Distance-Metrics","page":"Home","title":"Using Different Distance Metrics","text":"# Explicit metric configuration\nlineages = process_lineages(df;\n    distance_metric = NormalizedHammingDistance(),\n    clustering_method = HierarchicalClustering(0.1f0),\n    linkage = :average\n)","category":"section"},{"location":"#Diagnostic:-Finding-Ties","page":"Home","title":"Diagnostic: Finding Ties","text":"# Identify lineages where multiple clones have the same max frequency\nties = hardest_tie_summary(df; atol=0.01)\nfilter(:hardest_tied => identity, ties)  # Show only tied lineages\n\nFor detailed function signatures and options, see the API Reference below.\n\n","category":"section"},{"location":"#LineageCollapse.AbstractDistanceMetric","page":"Home","title":"LineageCollapse.AbstractDistanceMetric","text":"Abstract type for all distance metrics used in sequence comparison.\n\n\n\n\n\n","category":"type"},{"location":"#LineageCollapse.AbstractTieBreaker","page":"Home","title":"LineageCollapse.AbstractTieBreaker","text":"Abstract type for tie-breaking strategies used when selecting lineage representatives.\n\n\n\n\n\n","category":"type"},{"location":"#LineageCollapse.ClusteringMethod","page":"Home","title":"LineageCollapse.ClusteringMethod","text":"Abstract type for clustering methods.\n\n\n\n\n\n","category":"type"},{"location":"#LineageCollapse.CollapseStrategy","page":"Home","title":"LineageCollapse.CollapseStrategy","text":"Abstract type for lineage collapse strategies.\n\n\n\n\n\n","category":"type"},{"location":"#LineageCollapse.HammingDistance","page":"Home","title":"LineageCollapse.HammingDistance","text":"HammingDistance <: AbstractDistanceMetric\n\nHamming distance metric - counts the number of mismatches between sequences.\n\n\n\n\n\n","category":"type"},{"location":"#LineageCollapse.Hardest","page":"Home","title":"LineageCollapse.Hardest","text":"Hardest <: CollapseStrategy\n\nCollapse strategy that selects exactly one representative per lineage.\n\n\n\n\n\n","category":"type"},{"location":"#LineageCollapse.HierarchicalClustering","page":"Home","title":"LineageCollapse.HierarchicalClustering","text":"HierarchicalClustering{T} <: ClusteringMethod\n\nHierarchical clustering with a distance cutoff.\n\nFields\n\ncutoff::T: Distance threshold for cluster merging\n\nExample\n\nHierarchicalClustering(1.0f0)  # Merge clusters within distance 1.0\n\n\n\n\n\n","category":"type"},{"location":"#LineageCollapse.LevenshteinDistance","page":"Home","title":"LineageCollapse.LevenshteinDistance","text":"LevenshteinDistance <: AbstractDistanceMetric\n\nLevenshtein (edit) distance metric.\n\n\n\n\n\n","category":"type"},{"location":"#LineageCollapse.MostCommonVdjNtTieBreaker","page":"Home","title":"LineageCollapse.MostCommonVdjNtTieBreaker","text":"MostCommonVdjNtTieBreaker\n\nA tie-breaker that selects the representative based on the most common VDJ_nt sequence weighted by count, matching igdiscover's clonotypes behavior.\n\nFor each lineage, it:\n\nSums the count for each unique vdj_nt sequence\nSelects the vdj_nt with the highest total count\nReturns the first row with that vdj_nt\n\n\n\n\n\n","category":"type"},{"location":"#LineageCollapse.NormalizedHammingDistance","page":"Home","title":"LineageCollapse.NormalizedHammingDistance","text":"NormalizedHammingDistance <: AbstractDistanceMetric\n\nNormalized Hamming distance - mismatches divided by sequence length.\n\n\n\n\n\n","category":"type"},{"location":"#LineageCollapse.Soft","page":"Home","title":"LineageCollapse.Soft","text":"Soft{T} <: CollapseStrategy\n\nCollapse strategy that keeps all clones above a frequency threshold.\n\nFields\n\ncutoff::T: Minimum clone frequency to retain (0.0 to 1.0)\n\nExample\n\nSoft(0.2)  # Keep clones with frequency ≥ 20%\n\n\n\n\n\n","category":"type"},{"location":"#LineageCollapse.TieBreaker","page":"Home","title":"LineageCollapse.TieBreaker","text":"TieBreaker <: AbstractTieBreaker\n\nA configurable tie-breaker that sorts candidates by specified column criteria.\n\nFields\n\ncriteria::Vector{Pair{Symbol,Bool}}: Sorting criteria as column => descending pairs. Columns are checked in order; true means sort descending (higher is better).\n\nExample\n\n# Sort by count descending, then by cdr3 ascending (lexicographic)\nTieBreaker([:count => true, :cdr3 => false])\n\n\n\n\n\n","category":"type"},{"location":"#LineageCollapse.ByCdr3Count-Tuple{}","page":"Home","title":"LineageCollapse.ByCdr3Count","text":"ByCdr3Count()\n\nTie-breaker that selects by highest CDR3 count, then lexicographic CDR3.\n\n\n\n\n\n","category":"method"},{"location":"#LineageCollapse.ByFirst-Tuple{}","page":"Home","title":"LineageCollapse.ByFirst","text":"ByFirst()\n\nTie-breaker that selects the first candidate (no sorting).\n\n\n\n\n\n","category":"method"},{"location":"#LineageCollapse.ByLexicographic-Tuple{}","page":"Home","title":"LineageCollapse.ByLexicographic","text":"ByLexicographic()\n\nTie-breaker that selects by lexicographically smallest CDR3.\n\n\n\n\n\n","category":"method"},{"location":"#LineageCollapse.ByMostCommonVdjNt-Tuple{}","page":"Home","title":"LineageCollapse.ByMostCommonVdjNt","text":"ByMostCommonVdjNt()\n\nCreate a tie-breaker that matches igdiscover's clonotypes representative selection.\n\nSelects the representative by finding the VDJnt sequence with the highest total count across all members of the lineage, then returns the first row with that VDJnt.\n\nRequires columns: vdj_nt, count\n\n\n\n\n\n","category":"method"},{"location":"#LineageCollapse.ByMostNaive-Tuple{}","page":"Home","title":"LineageCollapse.ByMostNaive","text":"ByMostNaive()\n\nTie-breaker prioritizing sequences closest to germline (highest V/J identity), then by VDJ count, CDR3 count, and lexicographic CDR3.\n\n\n\n\n\n","category":"method"},{"location":"#LineageCollapse.BySequenceCount-Tuple{}","page":"Home","title":"LineageCollapse.BySequenceCount","text":"BySequenceCount()\n\nTie-breaker that selects by highest sequence count, then lexicographic CDR3.\n\n\n\n\n\n","category":"method"},{"location":"#LineageCollapse.ByVdjCount-Tuple{}","page":"Home","title":"LineageCollapse.ByVdjCount","text":"ByVdjCount()\n\nTie-breaker that selects by highest VDJ nucleotide count, then lexicographic CDR3.\n\n\n\n\n\n","category":"method"},{"location":"#LineageCollapse.collapse_lineages","page":"Home","title":"LineageCollapse.collapse_lineages","text":"collapse_lineages(df::DataFrame, strategy=Hardest(); tie_breaker, tie_atol) -> DataFrame\n\nCollapse lineages to representative sequences.\n\nArguments\n\ndf::DataFrame: Data from process_lineages with lineage_id column\nstrategy::CollapseStrategy=Hardest(): Collapse strategy\nHardest(): One representative per lineage (highest clone frequency)\nSoft(cutoff): Keep all clones with frequency ≥ cutoff\n\nKeyword Arguments\n\ntie_breaker::AbstractTieBreaker=ByMostCommonVdjNt(): Strategy for breaking ties\ntie_atol::Real=0.0: Tolerance for frequency comparison\n\nReturns\n\nFor Hardest():\n\nSelected rows with added count::Int (sum of counts) and nVDJ_nt::Int (unique VDJ sequences)\n\nFor Soft(cutoff):\n\nRows meeting threshold with added clone_frequency::Float64 and sequence_count::Int\n\n\n\n\n\n","category":"function"},{"location":"#LineageCollapse.compute_distance","page":"Home","title":"LineageCollapse.compute_distance","text":"compute_distance(metric::AbstractDistanceMetric, x::LongDNA{4}, y::LongDNA{4}) -> Float32\n\nCompute distance between two DNA sequences using the specified metric.\n\n\n\n\n\n","category":"function"},{"location":"#LineageCollapse.compute_pairwise_distance-Union{Tuple{S}, Tuple{M}, Tuple{M, AbstractVector{S}}} where {M<:AbstractDistanceMetric, S<:BioSequences.LongSequence{BioSequences.DNAAlphabet{4}}}","page":"Home","title":"LineageCollapse.compute_pairwise_distance","text":"compute_pairwise_distance(metric, sequences) -> Matrix{Float32}\n\nCompute pairwise distance matrix for DNA sequences.\n\n\n\n\n\n","category":"method"},{"location":"#LineageCollapse.deduplicate_data","page":"Home","title":"LineageCollapse.deduplicate_data","text":"deduplicate_data(df::DataFrame, use_barcode::Bool=false)::DataFrame\n\nDeduplicate the input DataFrame based on sequence or sequence+barcode.\n\nArguments\n\ndf::DataFrame: Input DataFrame.\nuse_barcode::Bool=false: Whether to use barcode for deduplication.\n\nReturns\n\nDataFrame: Deduplicated DataFrame.\n\n\n\n\n\n","category":"function"},{"location":"#LineageCollapse.hardest_tie_summary-Tuple{DataFrames.DataFrame}","page":"Home","title":"LineageCollapse.hardest_tie_summary","text":"hardest_tie_summary(df::DataFrame; atol=0.0) -> DataFrame\n\nDiagnostic function to identify lineages with tied maximum clone frequencies.\n\n\n\n\n\n","category":"method"},{"location":"#LineageCollapse.load_data-Tuple{String}","page":"Home","title":"LineageCollapse.load_data","text":"load_data(filepath::String; \n          delimiter::Char='\t', \n          required_columns=[:sequence_id, :sequence, :v_sequence_end, :j_sequence_start, :cdr3, :v_call, :j_call, :stop_codon])::DataFrame\n\nLoad data from a file (compressed or uncompressed) and return a DataFrame.\n\nArguments\n\nfilepath::String: Path to the data file.\ndelimiter::Char='\t': Delimiter used in the data file (default: tab).\nrequired_columns::Vector{Symbol}: Required columns to select from the data file.\n\nReturns\n\nDataFrame: DataFrame containing the loaded data.\n\nThrows\n\nArgumentError: If any of the required columns are missing in the data file.\n\n\n\n\n\n","category":"method"},{"location":"#LineageCollapse.perform_clustering-Tuple{HierarchicalClustering, Symbol, AbstractMatrix{<:AbstractFloat}}","page":"Home","title":"LineageCollapse.perform_clustering","text":"perform_clustering(method::HierarchicalClustering, linkage, dist_matrix) -> Vector{Int}\n\nPerform hierarchical clustering and return cluster assignments.\n\n\n\n\n\n","category":"method"},{"location":"#LineageCollapse.preprocess_data-Tuple{DataFrames.DataFrame}","page":"Home","title":"LineageCollapse.preprocess_data","text":"preprocess_data(df::DataFrame; min_d_region_length::Union{Int,Nothing}=nothing, deduplicate::Bool=false, use_barcode::Bool=false)::DataFrame\n\nPreprocess the input DataFrame by performing data cleaning and transformation.\n\nArguments\n\ndf::DataFrame: Input DataFrame.\nmin_d_region_length::Union{Int,Nothing}=nothing: Minimum length of the D region to keep. If nothing, no filtering is applied.\ndeduplicate::Bool=false: Whether to deduplicate the DataFrame.\nuse_barcode::Bool=false: Whether to use barcode for deduplication (only applicable if deduplicate is true).\n\nReturns\n\nDataFrame: Preprocessed DataFrame.\n\n\n\n\n\n","category":"method"},{"location":"#LineageCollapse.process_lineages-Tuple{DataFrames.DataFrame}","page":"Home","title":"LineageCollapse.process_lineages","text":"process_lineages(df::DataFrame; distance_metric, clustering_method, linkage) -> DataFrame\n\nProcess sequences into lineages with explicit metric and clustering configuration.\n\nKeyword Arguments\n\ndistance_metric::AbstractDistanceMetric=HammingDistance(): Distance metric for CDR3 comparison\nclustering_method::ClusteringMethod=HierarchicalClustering(1.0f0): Clustering method and cutoff\nlinkage::Symbol=:single: Hierarchical clustering linkage\n\nSee process_lineages(df, threshold) for return value documentation.\n\n\n\n\n\n","category":"method"},{"location":"#LineageCollapse.process_lineages-Union{Tuple{T}, Tuple{DataFrames.DataFrame, T}} where T<:Union{AbstractFloat, Integer}","page":"Home","title":"LineageCollapse.process_lineages","text":"process_lineages(df::DataFrame, threshold; linkage=:single) -> DataFrame\n\nProcess sequences into lineages using CDR3 clustering.\n\nArguments\n\ndf::DataFrame: Preprocessed data with columns v_call_first, j_call_first, cdr3, cdr3_length, d_region\nthreshold: Clustering threshold. Integer for absolute mismatches, Float (0.0-1.0) for fraction of CDR3 length.\nlinkage::Symbol=:single: Hierarchical clustering linkage (:single, :complete, :average)\n\nReturns\n\nDataFrame with added columns:\n\nlineage_id::Int: Unique lineage identifier\ncluster::Int: Cluster assignment within V/J group\ncluster_size::Int: Number of sequences in cluster\nmin_distance::Float32: Minimum distance to other CDR3s in cluster\ncdr3_count::Int: Count of this CDR3 in cluster\nmax_cdr3_count::Int: Maximum CDR3 count in cluster\ncdr3_frequency::Float64: cdr3_count / max_cdr3_count\n\n\n\n\n\n","category":"method"}]
}
